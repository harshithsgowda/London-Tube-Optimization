# -*- coding: utf-8 -*-
"""Final_Code.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wvMTtB3ZPHTyo7EwyNEKbxiGCdfd3XYh
"""

import pandas as pd
import networkx as nx
from scipy.optimize import linprog

# Load dataset
file_path = "/content/Combined_Station_Data_with_Full_Names.csv"
data = pd.read_csv(file_path)

# Data Cleaning
columns_needed = ["Station 1 Full", "Station 2 Full", "Distance", "Line_x",
                  "2330-2345", "2345-0000", "0000-0015", "0015-0030", "0030-0045", "0045-0100"]
cleaned_data = data[columns_needed]

cleaned_data.rename(columns={
    "Station 1 Full": "Station_1",
    "Station 2 Full": "Station_2",
    "Line_x": "Line",
    "Distance": "Distance_km"
}, inplace=True)

cleaned_data['Distance_km'] = pd.to_numeric(cleaned_data['Distance_km'], errors='coerce')

time_slots = ["2330-2345", "2345-0000", "0000-0015", "0015-0030", "0030-0045", "0045-0100"]
cleaned_data['Total_Flow'] = cleaned_data[time_slots].sum(axis=1, skipna=True)
cleaned_data.drop(columns=time_slots, inplace=True)
cleaned_data.dropna(inplace=True)

# Graph Representation
G = nx.Graph()

for _, row in cleaned_data.iterrows():
    G.add_edge(
        row['Station_1'],
        row['Station_2'],
        distance=row['Distance_km'],
        flow=row['Total_Flow'],
        line=row['Line']
    )

# Dijkstra's Algorithm for Shortest Path
def find_shortest_path(graph, source, target, weight="distance"):
    try:
        path = nx.dijkstra_path(graph, source, target, weight=weight)
        path_length = nx.dijkstra_path_length(graph, source, target, weight=weight)
        return path, path_length
    except nx.NetworkXNoPath:
        return None, float("inf")

source_station = input("Enter the Source Station")
target_station = input("Enter the Destination")
shortest_path, shortest_distance = find_shortest_path(G, source_station, target_station, weight="distance")

# Goal Programming for Combined Optimization
edges = [(u, v, d['distance'], d['flow']) for u, v, d in G.edges(data=True)]
stations = list(G.nodes)
station_index = {station: i for i, station in enumerate(stations)}
num_stations = len(stations)
num_edges = len(edges)

c = [edge[2] + edge[3] for edge in edges]

A_eq = [[0] * num_edges for _ in range(num_stations)]
b_eq = [0] * num_stations

source_idx = station_index[source_station]
b_eq[source_idx] = 1

target_idx = station_index[target_station]
b_eq[target_idx] = -1

for edge_idx, (u, v, _, _) in enumerate(edges):
    u_idx = station_index[u]
    v_idx = station_index[v]
    A_eq[u_idx][edge_idx] = 1
    A_eq[v_idx][edge_idx] = -1

bounds = [(0, 1) for _ in range(num_edges)]

result = linprog(c, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method="highs")

if result.success:
    optimized_edges = [edges[i] for i, flow in enumerate(result.x) if flow > 0.5]
    optimized_path = [source_station]
    current_station = source_station
    while current_station != target_station:
        for u, v, _, _ in optimized_edges:
            if u == current_station:
                optimized_path.append(v)
                current_station = v
                break
            elif v == current_station:
                optimized_path.append(u)
                current_station = u
                break
else:
    optimized_path = None

# Function to extract the full details of the optimized path
def get_path_details(graph, path):
    if not path:
        return None
    path_details = []
    total_distance = 0
    total_flow = 0
    for i in range(len(path) - 1):
        u, v = path[i], path[i + 1]
        edge_data = graph[u][v]
        path_details.append({
            "From": u,
            "To": v,
            "Line": edge_data["line"],
            "Distance (km)": edge_data["distance"],
            "Passenger Flow": edge_data["flow"]
        })
        total_distance += edge_data["distance"]
        total_flow += edge_data["flow"]
    return path_details, total_distance, total_flow

# Get details for the optimized path
optimized_path_details, total_optimized_distance, total_passenger_flow = get_path_details(G, optimized_path)

# Print the optimized pathway details in the desired format
if optimized_path_details:
    print("Optimized Pathway Details:")
    for detail in optimized_path_details:
        print(f"From: {detail['From']} -> To: {detail['To']} | Line: {detail['Line']} | Distance: {detail['Distance (km)']} km | Passenger Flow: {detail['Passenger Flow']}")
    print(f"Total Optimized Distance: {total_optimized_distance} km")
    print(f"Total Passenger Flow: {total_passenger_flow}")
    print(f"Pathway Chosen: {' -> '.join(optimized_path)}")
else:
    print("No optimized pathway found.")

